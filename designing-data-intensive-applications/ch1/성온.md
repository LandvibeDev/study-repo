# 새롭게 알게된 점

애플리케이션을 설계할 때 고려할 점을 알 수 있었다. 크게 신뢰성, 확장성, 유지보수성 관점에서 고려해야 한다.

각 관점에서 아래 세부사항을 고려한다.

신뢰성은

- 하드웨어 결함
- 소프트웨어 오류
- 인적 오류
- 신뢰성의 중요 여부

확장성은

- 부하
- 성능
- 부하 대응 접근 방식

유지보수성은

- 운용성을 통한 운영의 편리함 만들기
- 단순성을 통한 복잡도 관리
- 발전성을 통한 변화를 쉽게 만들기

또한 기능의 특성을 고려하여 애플리케이션을 설계해야 한다.

# 어려웠거나 이해하지 못한 점

# 추가 내용

kafka, message queue redis, cache 만능이 되고 있다. redis 는 클러스터 관리만 잘 하면 성능이 뛰어나기 때문에 뭐를 해도 괜찮은 시스템이긴 하다.

설정으로 파일에 쓰는 것을 많이

# 내용 정리

오늘날 많은 애플리케이션은 데이터 중심(data-intensive)적으로 성능은 CPU보다는 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도에 영향을 받는다.

데이터 중심 애플리케이션은 다음과 같은 기능을 필요로 한다.

- 데이터베이스
- 캐시
- 검색 색인
- 스트림 처리
- 일괄 처리

애플리케이션을 만들 때 어떤 도구와 어떤 접근 방식이 수행중인 작업에 가장 적합한지 생각해야한다. 단 하나의 도구만으로 할 수 없는 것을 해야하는 경우 도구들을 결합하기 어려울 수도 있다. 이 책에서는 데이터 시스템의 원칙과 실용성, 그리고 이를 활용한 데이터 중심 애플리케이션을 개발하는 방법을 다룬다.

## 데이터 시스템에 대한 생각

일반적으로 데이터베이스, 큐, 캐시 등은 서로 다른 접근방식과 특성을 가지고 있어 매우 다른 범주의 속하는 도구로 생각하는데, 왜 포괄적으로 데이터 시스템이라는 용어로 정의해야할까?

데이터 저장과 처리를 위한 여러 새로운 도구들이 최근에 생겨나는데, 다양한 사용 사례에 최적화 되었기에 더이상 전통적인 분류에 딱 맞지 않는다. 점점 더 많은 애플리케이션이 단일 도구로는 더 이상 데이터 처리와 저장 모두를 만족시킬 수 없는 과도하고 광범위한 요구사항을 갖고 있다.

대부분의 소프트웨어 시스템에서 중요하게 여기는 세 가지 관심사

1. 신뢰성(Reliability)
2. 확장성(Scalability)
3. 유지보수성(Maintainability)

## 신뢰성(Reliability)

`올바르게 동작함`, `무언가 잘못되더라도 지속적으로 올바르게 동작함`

잘못될 수 있는 일을 결함(fault)라고 하며, 이를 예측하고 대처할 수 있는 시스템을 내결함성(fault-tolerant) 또는 탄력성(resilient)을 지녔다고 한다. 결함이라고 해서 장애는 아니다. 결함 확률을 0으로 하는것은 불가능 하며, 장애가 발생하지 않도록 결함성 구조를 설계하는 것이 중요하다.

- 결함: 사양에서 벗어난 한 시스템의 요소
- 장애: 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우

### 하드웨어 결함

시스템 장애율을 줄이기 위한 첫 번째 대응으로 각 하드웨어 구성 요소에 중복을 추가하는 방법이 일반적이다.

- 디스크는 RAID 구성으로 설치
- 서버는 이중 전원 디바이스와 핫 스왑 가능한 CPU
- 데이터센터는 건전지와 예비 전원용 디젤 발전기 설치

최근에 데이터 양과 애플리케이션의 계산 요구가 늘어나면서 많은 수의 장비를 사용하게 되고, 이와 비례해 하드웨어 결함율도 증가 소프트웨어 내결함성 기술을 사용하거나 하드웨어 중복성을 추가해 전체 장비의 손실을 견딜수 있는 시스템을 구성해야한다.

### 소프트웨어 오류

하드웨어 결함은 일반적으로 독립적이지만, 소프트웨어 오류는 노드간 상관관계가 있어 하드웨어 결함보다 많이 유발하는 경향이 있다.

- 잘못된 특정 입력이 있을 때 모든 애플리케이션 서버 인스턴스가 죽는 소프트웨어 버그(e.g. 리눅스 2012년 6월 30일 윤초 버그)
- 공유 자원을 과도하게 사용하는 프로세스
- 반응이 없거나 잘못된 응답을 반환하는 서비스
- 하나의 작은 결함으로 더 많은 결함이 발생하는 연쇄 장애

해결책

1. 시스템의 가정과 상호작용에 주의 깊게 생각
2. 빈틈없는 테스트
3. 프로세스 격리
4. 죽은 프로세스의 재시작 허용
5. 프로덕션 환경에서 시스템동작 측정, 모니터링, 분석

### 인적 오류

해결책

1. 오류의 가능성을 최소화하는 방향으로 시스템을 설계하라
2. 사람이 가장 많이 실수하는 장소에서 사람의 실수로 장애가 발생할 수 있는 부분을 분리하라
3. 단위 테스트부터 전체 시스템 통합 테스트와 수동 테스트까지 모든 수준에서 철저하게 테스트하라
4. 장애 발생의 영향을 최소화하기 위헤 인적 오류를 빠르고 쉽게 복구할 수 있도록 하라
5. 성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책을 마련하라
6. 조작 교육과 실습을 시행하라

## 확장성(Scalability)

시스템이 현재 안정적이라고 해서 미래에도 안정적이라는 보장은 없다. 흔한 이유로 부하 증가에 의해 성능저하가 일어난다.

확장성을 논한다는 것은 `시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?`, `추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?` 같은 질문을 고려한다는 의미이다.

### 부하 기술하기

부하 매개변수로 나타낼 수 있다.

- 웹 서버의 초당 요청 수
- 데이터베이스의 읽기 대 쓰기 비율
- 대화방의 동시 활성 사용자
- 캐시 적중률

평균적인 경우가 중요할 수도 있고 소수의 극단적인 경우가 병목 현상의 원인일 수도 있다.

### 성능 기술하기

일괄 처리 시스템은 보통 처리량(throughput), 온라인 시스템은 서비스 응답 시간(response time)에 시스템 성능의 중점을 둔다.

서비스 응답 시간 동일한 요청에 대해서도 매번 다른 응답 시간 -> 특정 값 보다는 분포로 생각

- 프로세스 처리시간 외에도 네트워크 패킷 손실과 TCP 재전송, 가비지 컬렉션 등등 여러 원인으로 추가 지연이 생길 수 있다.

평균응답 시간 보다는 백분위를 사용

- 예를들어 p50 200ms 인 경우 사용자의 50%는 200ms 이상의 응답시간을 경험한다는 의미.
- 특히, 평균적인 응답이 아닌 특이 값(비정상적으로 느린 응답시간)을 알고 싶으면 p95, p99, p99.9를 사용(꼬리 지연 시간, tail latency)하는 것이 좋다.
    - 서비스의 사용자 경험에 직접적인 영향을 주기 때문에 중요하다.
    - 아마존은 p99.9 쓴다고 합니다
- 상위 백분위의 소수의 느린 요청에 의해 후속 처리가 지체되는 경우가 발생(선두 차단, head-of-line blocking)할 수 있기에 매우 중요
    - 클라이언트 쪽 응답 시간이 중요

### 부하 대응 접근 방식

부하 증가하더라도 좋은 성능을 유지하려면 어떻게 해야 할까?

용량확장(Scaling up)

- 좀 더 강력한 장비로 이동(수직확장, vertical scaling) 규모확장(Scaling out)
- 다수의 장비로 부하 분산(수평확장, horizontal scaling)

아키텍처를 결정하는 요소

- 읽기, 쓰기의 양
- 데이터의 양 / 복잡도
- 응답시간 요구사항
- 접근 패턴

범용적이고 모든 상황에 맞는 확장 아키텍처는 없다. 따라서 애플리케이션의 주요 동작이 무엇인지, 잘하지 않는 동작이 무엇인지 등을 고려하여(부하 매개변수를 잘 파악하여) 적합한 확장성을 갖춘 아키텍처를 구성해야한다.

## 유지보수성(Maintainability)

버그 수정, 시스템 운영 유지, 장애 조사, 새로운 플랫폼 적용, 새 사용 사례를 위한 변경, 기술 채무 상환, 새로운 기능 추가 등등

소프트웨어 시스템 설계 원칙 세가지

- 운용성: 운영하기 쉽게 만들어라
- 단순성: 새로운 사람이 이해하기 쉽게 만들어라
- 발전성: 이후 쉽게 변경할 수 있게 만들어라

### 운용성:운영의 편리함 만들기

> 좋은 운영은 종종 나쁜 소프트웨어의 제약을 피하는 대안이 될 수 있다. 하지만 좋은 소프트웨어라도 나쁘게 운영할 경우 작동을 신뢰할 수 없다.
> 

시스템이 지속해서 원활하게 작동하려면 운영팀이 필요하며, 다음과 같은 작업을 책임진다.

- 시스템 모니터링 및 서비스 복원
- 시스템 장애, 성능저하 분석
- 보안패치 등 플랫픔 최신상태 유지
- 시스템 간 영향관계 분석 및 문제 사전 예방
- 미래에 발생 가능한 문제 예측 및 예방
- 배포, 설정 등 모범사례 도구 마련
- 플랫폼 이동 등 유지보수 태스크 수행
- 시스템 보안
- 운영 절차 정의
- 지식 공유 및 인수인계

### 단순성:복잡도 관리

복잡도는 작업의 진행을 느리게 하고 유지보수 비용이 증가시킨다.

복잡도의 증상

- 상태 공간의 급증
- 모듈 간 강한 커플링
- 복잡한 의존성
- 일관성 없는 명명과 용어
- 성능 문제 해결을 목표로한 해킹
- 임시방편으로 문제를 해결한 특수 사례

복잡도에 의해 예산과 일정이 초과되는 경우도 많으며, 복잡한 소프트웨어에서는 변경이 있을 때 버그가 생길 위험이 크다.

시스템을 단순하게 만든다는 것은 기능을 줄이는 것이 아니라, 우발적 복잡도(accidental complexity)를 줄인다는 뜻이다. 우발적 복잡도는 소프트웨어가 풀어야할 문제에 내재하고 있지 않고 구현에서만 발생한다고 정의된다.

우발적 복잡도를 제거하기 위한 최상의 도구는 `추상화`다.

- 깔끔하고 직관적인 외관 아래로 많은 세부 구현을 숨길 수 있다.
- 다른 다양한 애플리케이션에서도 사용 가능하다.

### 발전성:변화를 쉽게 만들기

시스템의 요구사항은 끊임없이 변할 가능성이 크다.

시스템의 간단함과 추상화를 통해 데이터 시스템 변경을 쉽게하고 변화된 요구사항에 시스템을 맞출 수 있다. 간단하고 쉽게 만든 시스템이 수정하기도 쉬운법 (소프트웨어 시스템 설계 원칙)

## 정리

애플리케이션을 신뢰할 수 있고 확장가능하며 유지보수하기 쉽게 만들어주는 간단한 해결책은 없다. 여러 애플리케이션에서 사용된 다양한 사례를 알고 분석을 통해 애플리케이션에 적합한 패턴과 기술을 알 수 있다.
