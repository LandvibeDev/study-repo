# 3장. 저장소와 검색

# 새롭게 알게된 점

# 어려웠거**나 이해하지 못한 점**

# 추가 내용

---

# <<아래부터 내용 정리>>

데이터베이스가 데이터를 **저장**하는 방법, 데이터를 요청했을 때 다시 **찾는** 방법

**트랜잭션** 작업부하에 맞춰 최적화된 저장소 엔진과 **분석**에 최적화된 저장소 엔진

**로그 구조(log-structured)** 계열 저장소 엔진과 (B트리 같은) **페이지 지향(page-oriented)** 계열 저장소 엔진 검토

# 데이터베이스를 강력하게 만드는 데이터 구조

색인

- 데이터베이스에서 특정 키의 값을 효율적으로 찾기 위해 사용
- 원하는 데이터의 위치를 찾는 데 도움을 줌
- 데이터 베이스의 내용에는 영향을 미치지 않고 **성능**에만 영향을 줌
- 색인을 잘 선택하면 **읽기** 질의 속도가 향상됨
- 하지만 모든 색인은 **쓰기** 속도를 떨어뜨림 (데이터를 쓸 때마다 색인도 갱신해야 하기 때문)

## 해시 색인

비트 캐스크 저장소 엔진

- 해시 맵을 전부 메모리에 저장 (많은 공간 필요)
- 각 키의 값이 자주 갱신되는 상황에 적합
    - 키당 쓰기 수가 많지만 고유키가 많지 않아 메모리에 모두 보관 가능한 경우
- 디스크 공간이 부족해질 경우
    - 특정 크기의 세그먼트로 나누고 컴팩션 수행 (로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지)

실제 구현에서 중요한 문제

- 파일 형식
    - CSV 대신 바이트 단위의 문자열 길이를 부호화한 다음 원시 문자열을 부호화하는 바이너리가 더 빠르고 간단하다.
- 레코드 삭제
    - 키와 관련된 값을 삭제하려면 데이터 파일에 특수한 삭제 레코드(툼스톤)을 추가해야 한다.
- 고장(Crash) 복구
    - 데이터베이스 재시작 시 인메모리 해시 맵은 손실된다.
    - 전체 세그먼트 파일을 읽어서 복구할 수 있으나 느릴 수 있다.
    - 조금 더 빠른 로딩을 위해 스냅숏을 디스크에 만들어 저장해둘 수 있다.
- 부분적으로 레코드 쓰기
    - 데이터베이스가 로그에 레코드를 추가하다 죽을 경우 체크섬으로 손상된 부분을 무시할 수 있다.
- 동시성 제어
    - 쓰기를 엄격하게 순차적으로 로그에 추가 시 하나의 쓰레드만 사용한다.
    - 데이터 파일 세그먼트는 추가 전용이거나 불변이므로 다중 스레드로 동시에 읽을 수 있다.

해시 색인의 제한 사항

- 해시 테이블은 메모리에 저장해야 하므로 키가 너무 많으면 문제가 된다.
- 범위 질의(range query)에 효율적이지 않다. 예를 들어 kitty0000과 kitty9999 사이 모든 키를 쉽게 스캔할 수 없다. 해시 맵에서 모든 개별 키를 조회해야 한다.

## SS테이블과 LSM 트리

SS테이블

- 핵심: 정렬된 상태를 유지하고 이것의 장점을 활용하는 것
    - 장점: 범위 질의에 효율적인 대응 가능 - 다른 키로 대상 키 위치를 찾아갈 수 있음
- 키-값 쌍을 키로 정렬
- 정렬된 문자열 테이블 (Sorted String Table, SS 테이블)
- 장점: 해시 색인을 가진 로그 세그먼트 대비
    - 파일이 사용 가능한 메모리보다 크더라도 간단하고 효율적임, 병합정렬 알고리즘에서 사용하는 방식과 유사
    - 파일에서 특정 키를 찾기 위해 메모리에 모든 키의 색인을 유지할 필요가 없다. 정렬된 다른 키로 유추 가능
    - 레코드를 블록으로 압축 시 색인은 이 시작점을 가리키게 됨. 이때 디스크 공간 절약 및 I/O 대역폭 사용도 줄일 수 있다.

SS테이블 생성과 유지

- 데이터를 키로 정렬하려면 어떻게 해야 할까?
- 레드 블랙 트리(red-black tree)나 AVL 트리
- 이런 데이터 구조를 이용하면 임의 순서로 키를 삽입하고 정렬된 순서로 해당 키를 다시 읽을 수 있다.
- 저장소 엔진을 다음과 같이 만들 수 있다.
    - 멤테이블 등등

SS테이블에서 LSM 트리 만들기

- 정렬된 파일 병합과 컴팩션 원리를 기반으로 하는 저장소 엔진을 LSM 저장소 엔진이라 부른다.

성능 최적화

- LSM 트리 알고리즘은 데이터베이스에존재하지 않는 키를 찾는 경우 느릴 수 있음
    - 블룸 필터(bloom filter)로 최적화 가능
    - 블룸 필터는 집합 내용을 근사한 메모리 효율적 데이터 구조
- SS테이블을 압축하고 병합하는 순서와 시기를 결정하는 전략
    - 크기 계층(size-tiered): 상대적으로 좀 더 새롭고 작은 SS테이블을 더 오래됐고 큰 SS테이블에 저장
    - 레벨 컴팩션(leveled compaction): 키 범위를 더 작은 SS테이블로 나누고 오래된 데이터는 개별 “레벨”로 이동하므로 컴팩션을 점진적으로 진행해 디스크 공간을 덜 사용한다.

## B 트리

페이지 지향 계열 저장소

많은 관계형/비관계형 데이터베이스에서 표준 색인 구현으로 사용

SS테이블과 공통점은 키로 정렬된 키-값 쌍을 유지하므로 키-값 검색과 범의 질의에 효율적이라는 점 뿐

차이점은 로그 구조화 색인은 **가변 크기를 가진 세그먼트**로 나누고 순차적으로 기록하고, B트리는 4KB 정도의 **고정 크기 블록이나 페이지**로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기를 함

분기계수

키의 값 갱신/추가 알고리즘이 있고 이 알고리즘으로 트리가 계속 균형을 유지할 수 있다.

n개의 키를 가진 B트리는 **깊이가 항상 O(logn)**

신뢰할 수 있는 B트리 만들기

- 기본적인 쓰기 동작은 새로운 데이터를 디스크 상의 페이지에 덮어쓴다. 참조는 남는다.

B 트리 최적화

## B 트리와 LSM 트리 비교

B트리는

- LSM 트리 보다 **읽기가 빠름**
- 모든 데이터 조각을 최소한 두번 기록 (로그 + 트리 페이지)
- 일부만 바뀌어도 전체 페이지를 기록해야 하는 오버헤드 발생

B트리와 비교해서 LSM 트리의 장점

- B트리 보다 **쓰기가 빠름** (쓰기 처리량을 높게 유지할 수 있음)
- 압축률이 더 좋음

B트리와 비교해서 LSM 트리의 단점

- 컴팩션 과정이 종종 진행중인 읽기와 쓰기 성능에 영향을 줄 수 있음
- 쓰기 처리량이 높을 때 발생. 디스크의 쓰기 대역폭은 유한함. 그런데 데이터 크기가 커질 수록 컴팩션을 위해 많은 디스크 대역폭이 필요함

색인 관련해서

- B트리는 각 키가 색인의 한 곳에만 존재함
- 로그 구조화 저장소는 다른 세그먼트에 같은 키의 복사본이 존재할 수 있음
- 따라서 강력한 **트랜잭션** 시멘틱을 제공하는 데이터베이스에서는 **B트리**가 훨씬 매력적임

Q. LSM 트리 기반 저장소의 쓰기 장점을 가지고 쓴 적 있는가?

- 로그 시스템의 경우 쓰기 성능이 중요함
- ES는 쓰기가 빠른데 업데이트가 느림

## 기타 색인 구조

### 색인 안에 값 저장하기

- 키
    - 질의가 검색하는 대상
- 값
    - 질문의 실제 로우(문서, 정점) 또는 다른 곳에 저장된 로우를 가리키는 참조
    - 후자의 경우 로우가 저장된 곳을 힙 파일(heap file)이라 하고 특정 순서 없이 데이터를 저장
- 클러스터드 색인: 색인에서 힙 파일로 다시 이동하면 읽기 성능에 불이익이 많기 때문에 색인 안에 바로 색인된 로우를 저장하는 경우

### 다중 칼럼 색인

- 테이블의 다중 컬럼에 동시에 질의할 때 사용
- 종류: 결합 색인, 다차원 색인
- 결합 색인
    - 전화번호부
- 다채원 색인
    - 지리 공간 데이터
    - 특정 색상 범위의 제품 검색 (빨강, 초록, 파랑)의 3차원 색인
    - 날씨 관측 데이터베이스에서 2013년에 기온이 25도에서 30도 사이인 모든 관측을 효율적으로 찾기위해 (날짜, 기온)의 2차원 색인
- 사례
    - 클립, 채널
    - 

### 전문 검색과 퍼지 색인

- 위에서는 정확한 데이터를 대상으로 키의 정확한 값이나 정렬된 키의 값의 범위를 질의할 수 있다고 가정
- 철자가 틀린 단어와 같이 유사한 키에 대해서는 애매모호하게 (fuzzy) 질의할 땐 전문 검색 엔진을 사용한다.

### 모든 것을 메모리에 보관

- 지금까지 디스크에 대해 이야기함. 디스크는 지속성, 용량 당 가격이 저렴한 장점이 있음
- 인메모리 데이터베이스
    - 메모리에 올린다.
    - 지속성을 목표로 한다. 특수 하드웨어 사용 or 디스크에 변경 사항을 기록 or 디스크에 주기적인 스냅숏을 기록 or 다른 장비에 인메모리 상태를 복제
    - 사실 디스크 기반 저장소 엔진에서도 최근 사용한 디스크 블록을 메모리에 올리긴 함. 메모리가 충분하다면 인메모리보다 오히려 더 빠를수도 (인메모리 데이터 구조를 디스크에 기록하기 위한 부호화 과정이 필요하므로)
- 안티캐싱
- 비휘발성 메모리

# 트랜잭션 처리나 분석?

<aside>
💡 트랜잭션이 반드시 ACID 속성을 가질 필요는 없다. 
주기적으로 수행되는 일괄 처리 작업과 달리 클라이언트가 지연 시간이 낮은 읽기와 쓰기를 가능하게 한다는 의미다.

</aside>

트랜잭션 처리 시스템(OLTP) 과 분석 시스템(OLAP) 특성 비교

- 주요 읽기 패턴
- 주요 쓰기 패턴
- 주요 사용처
- 데이터 표현
- 데이터셋 크기

## 데이터 웨어하우징

OLTP 데이터베이스

- 사업 운영에 중요하므로 높은 가용성과 낮은 지연시간의 트랜잭션 처리
- 분석 질의 실행이 권장되지 않음 (트랜잭션 성능을 저하시킬 수 있음)

데이터 웨어하우스

- OLTP 데이터베이스의 읽기전용 복사본
- 분석질의를 부담없이 실행할 수 있음
- 이 데이터웨어하우스로 데이터를 가져오는 과정을 ETL(Extract-Transform-Load)라고 함
- OLTP 와 다르게 분석 패턴에 맞게 최적화 할 수 있음

## 분석용 스키마: 별 모양 스키마와 눈꽃송이 모양 스키마

분석에서는 데이터 모델의 다양성이 적음

테이블 관계가 시각화될 때 사실 테이블이 가운데 있고 차원 테이블로 둘러싸여 있음

사실 테이블(fact table)

- 각 스키마의 중심
- 각 로우는 특정 시각에 발생한 이벤트 (e.g. 고객의 제품 구매)

차원 테이블(dimension table)

- 다른 테이블을 가리키는 외래 키 참조
- 각 로우는 이벤트의 속성인 누가, 언제, 어디서, 무엇을 어떻게, 왜 를 나타냄

Q. 사례

- 주요 통계 데이터를 카프카를 통해서 HBase 에 적재 후 Hive 로 분석
- Hive 는 파티션 기반
    - /…/2019/01/01/xxx/

# 칼럼 지향 저장소

대부분의 OLTP 데이터베이스에서 저장소는 로우 지향 방식으로 데이터를 배치함

칼럼 지향 저장소는 모든 값을 하나의 로우에 함께 저장하지 않는 대신 각 칼럼별로 모든 값을 함께 저장함

## 칼럼 압축

대게 압축에 적합하다고 함

### 메모리 대역폭과 벡터화 처리

- 벡터화 처리(vectroized processing)

## 칼럼 저장소와 순서 정렬

칼럼 저장소에서 로우가 저장되는 순서가 반드시 중요하지는 않다. 하지만 이전의 ss테이블에서 했던 것 처럼 순서를 도입해 색인 매커니즘으로 사용할 수 있다.

### 다양한 순서 정렬

## 칼럼 지향 저장소에 쓰기

## 집계: 데이터 큐브와 구체화 뷰

원본 데이터를 변경하면 구체화 뷰를 갱신해야 하는데 이런 갱신으로 인한 쓰기는 비용이 비싸기 때문에 OLTP 데이터베이스에서는 구체화 뷰를 자주 사용하지 않는다. 데이터 웨어하우스는 읽기 비중이 크기 때문에 구체화 뷰를 사용하는 전략은 합리적이다. (실제로 읽기 성능이 향상되는지는 경우에 따라 다르다)

데이터 큐브(data cuve) 또는 OLAP 큐브

- 일반화된 구체화 뷰의 특별 사례

# 정리

데이터베이스가 어떻게 저장과 검색을 다루는지 근본적인 내용을 알아보았음

고수준에서 저장소 엔진은 트랜잭션 처리 최적화(OLTP)와 분석 최적화(OLAP)라는 큰 두가지 범주로 나뉨

OLTP

- 사용자 대면이므로 대용량의 요청을 받음
- 각 질의마다 작은 수의 레코드만 다룸
- 애플리케이션은 키의 일부만 사용하는 레코드를 요청하고 저장소 엔진은 요청한 키의 데이터를 찾기 이해 색인 사용
- 대게 디스크 탐색이 병속

OLAP

- 주로 비즈니스 분석가가 사용
- OLTP 시스템보다 적은 수의 질의를 다루지만 각 질의는 짧은 시간에 수백만 개의 레코드를 스캔해야 함
- 대게 디스크 대역폭(디스크 탑색이 아닌)이 병목
- 칼럼 지향 저장소는 이런 종류의 작업부하를 처리할 때 사용 가능한 솔루션

OLTP 측면에서 주요한 두 가지 관점

- 로그 구조화 관점에서 파일에 추가와 오래된 파일의 삭제만 허용하고 한 번 쓰여진 파일은 절대 갱신하지 않는다. - 비트캐스트, SS테이블, LSM 트리, 레벨DB, 카산드라, HBase, 루씬 등
- 제자리 갱신 관점에서 덮어쓰기 할 수 있는 고정 크기 페이지의 셋으로 디스크를 다룸. 이 관점에서 가장 큰 예는 B트리. B트리는 모든 주요 관계형 데이터베이스와 많은 비정형 데이터베이스에서도 사용
