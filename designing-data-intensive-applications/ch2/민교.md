### 관계형모델과 문서 모델

#### 관계형 데이터모델

- 오늘날 가장 잘 알려진 데이터모델. 

- 1960년대, 70년대에 메인프레임 컴퓨터에서 수행되는 비즈니스 데이터 처리.

-  보통트랜잭션처리(영업이나 은행거래, 항공 예약, 창고에 재고보관)와 일괄 처리(고객 송장 작성, 급여 지불, 보고).

- 컴퓨터가 강력해지고 네트워크화됨에 따라 본래 영역을 넘어 폭넓은 다양한 사용 사례에도 보편화



#### NOSQL의 등장

1970년대와 1980년대 초반에는 네트워크 모델과 계층 모델이 주요 대안이었지만, 결국 관계형 모델이 우위를 차지.

객체 데이터베이스는 1980년대 후반과 1990년대 초발에 나타났다가 사라짐.

XML 데이터베이스는 2000년대 초반에 등작했지만 마우 적체 채택.

2010년대에 NoSQL은 관계형 모델의 우위를 뒤집으려는 가장 최신 시도.

NoSQL 채택의 이유

- 대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 관계형 데이터보다 쉽게 할 수 있는 뛰어난 확장성의 필요

- 상요 데이터베이스 제품보다 무료 오픈소스 소프트웨어에 대한 선호도 확산

- 관계형 모델에서 지원하지 않는 특수 질의 동작

- 관계형 스키마의 제한에 대한 불만과 더욱 동적이고 표현력이 풍부한 데이터 모델에 대한 바람

다중 저장소 지속성(polyglot persistence)

미래에는 관계형 데이터베이스가 폭넓은 다양함을 가진 비관계형 데이터 스토어와 함께 사용될 것.



#### 객체 관계형 불일치

애플리케이션은 객체지향 프로그래밍 언어. 데이터를 관계형 테이블에 저장할려면 애플리케이션 코드와 데이터베이스 모델 객체 사이에 전환 계층이 필요. 이런 모델 사이의 분리를 임피던스 불일치(impedance mismatch)라고 부른다.

일부 개발자는 JSON 모델이 임피던스 불일치를 줄인다고 생각을 하지만, JSON 자체가 가지고 있는 문제들도 존재(데이터 부호화 형식, 스키마의 부족).

JSON 표현은 다중 테이블(multi-table) 스키마 보다 더 나은 지역성(locality)를 가진다.

관계형 예제에서 특정데이터(프로필)을 가져오려면 다중 질의(각 테이블에 user_id로 질의)를 수행하거나 다중 조인을 수행해야하지만, JSON 표현에서는 관련 정보가 한 곳에 있어 질의 하나로 충분하다.



#### 다대일과 다대다 관계

ID나 텍스트 문자열의 저장 여부는 중복의 문제.

 ID를 사용하는 경우

- 사람에게 의미 있는 정보는 한 곳에만 저장하고 그것을 참조하는 모든 것은 ID를 사용. 

- ID 자체는 아무런 의미가 없기 때문에 변경할 필요가 없음. 식별 정보를 변경해도 ID는 동일하게 유지

텍스트를 직접 저장

- 그것을 사용하는 모든 레코드에서 중복해서 저장.

- 정보가 변경될 경우, 모든 중복된 항목을 변경해야함. 쓰기 오버헤드와 불일치 위험이 존재.

다대일 관계에서는 문서 모델에 적합하지 않음. 문서 데이터베이스에서는 일대 다 트리 구조를 위해 조인이 필요하지 않지만 조인에 대한 지원이 약함.

데이터베이스에서 조인을 지원하지 않으면 애플리케이션 코드에서 조인을 흉내내야 한다.



#### 문서 데이터베이스는 역사를 반복하고 있나?

관계형 데이터베이스는 일상적으로 다대다 관계와 조인을 사용하지만 문서 데이터베이스는 그러하지 못하다. 이러한 한계를 해결하기 위해 두 가지 해결책(관계형 모델, 네트워크 모델)을 제안했다.

##### 네트워크 모델

코다실(Conference on Data Systems Languages, CODASYL)이라 불리는 위원회에서 표준화, 그래서 코다실 모델이라고도 불림.

계층 모델을 일반화. 네트워크 모델의 모든 레코드는 다중 부모가 있을 수 있다. 다대일과 다대다 관계를 모델링 할 수 있다.

레코드 간 연결은 포인터와 더 비슷. 레코드에 접근 하는 유일한 방법은 최상위 레코드(root record)에서부터 연속된 연결 경로를 따르는 방법이다. 이를 **접근 경로** 라 한다.

코다실에서의 질의는 레코드 목록을 반복해 접근 경로를 따라 끝에서 끝까지 커서를 움지여 수행한다. 만약 레코드가 다중 부모를 가진다면 다양한 관계를 모두 추적해야 한다.

데이터베이스 질의와 갱신을 위한 코드가 복잡하고 유연하지 못함. 원하는 데이터에 대한 경로가 없는 경우, 질의코드를 살펴보고, 새로운 접근 경로를 다루기 위해 재작성해야된다.

##### 관계형 모델

알려진 모든 데이터를 배치하는것. 임의 조건과 일치하는 테이블의 일부 또는 모든 로우를 선택해서 읽을 수 있고 일부 칼럼을 키로 지정해 칼럼과 일치하는 특정로우를 읽을 수 있다.

질의 최적화기(query optimizer)는 질의의 어느 부분을 어떤 순서로 실행할지를 결정하고 사용할 색인을 자동으로 결정, 이 선택이 접근경로가 된다.

이 접근 경로를 네트워크 모델과는 다르게 개발자가 아니라 질의 최적화기가 자동으로 만듬.

##### 문서 데이터베이스와의 비교

다대일과 다대다 관계를 표현할 때, 문서 참조(document reference)라고 불리는 고유한 식별자로 참조. 



#### 관계형 데이터베이스와 오늘날의 문서 데이터베이스

문서 데이터 모델을 선호하는 이유

- 스키마 유연성, 지역성에 기인한 더 나은 성능 때문.

- 일부 애플리케이션의 경우 애플리케이션에서 사용하는 데이터 구조와 더 가깝기 때문.

관계형 모델을 선호하는 이유

- 관계형 모델은 조인, 다대일, 다대다 관계를 더 잘 지원함.

##### 어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 할까?

애플리케이션에서 데이터가 문서와 비슷한 구조(일대다 관계 트리로 보통 한 번에 전체 트리를 적재)라면 문서 모델을 사용하는게 좋다.

문서 모델에는 제한이 있다. 문서 내 중첩 항목을 바로 참조할 수는 없다. 하지만 문서가 너무 깊게 중첩되지 않으면 일반적으로는 문제가 되지 않는다.

애플리케이션에서 다대다 관계를 사용하면 문서 모델은 매력이 떨어진다. 비정규화로 조인을 줄일 수 있지만, 데이터의 일관성을 유지하기 위해 추가작업이 필요할 수도 있다. 조인 또한 어플리케이션 코드에서 수행해야하는데 이는 데이터베이스 특화된 코드로 수행되는 조인보다 느리다.

##### 문서 모델에서의 스키마 유연성

스키마가 없다는 뜻은 임의의 키와 값을 문서에 추가할 수 있고 읽을 때 클라이언트는 문서에 포함된 필드의 존재 여부를 보장하지 않는다는 의미다.

쓰기 스키마(schema-on-write)(관계형 데이터베이스의 전통적인 접근 방식으로 스키마는 명시적이고 데이터 베이스는 쓰여진 모든 데이터가 스키마를 따르고 있음을 보장한다). 정적(컴파일 타임) 타입 확인과 비슷.

읽기 스키마(schema-on-read)(데이터 구조는 암묵적이고 데이터를 읽을 때만 해석된다). 동적(런타임) 타입 확인과 유사.

##### 질의를 위한 데이터 지역성

애플리케이션이 자주 전체 문서에 접근해야 할 때 저장소 지역성(storage locality)을 활용하면 성능 이점이 있다. 만약 데이터가 다중 테이블로 나눠졌으면 다중 색인 검색이 필요하고 이 경우 더 많은 디스크 탐색이 필요하고 더 많은 시간이 소요된다.

지역성의 이점은 한 번에 해당 문서의 많은 부분을 필요로 하는 경우에만 적용된다. 대게 문서의 작은 부분에만 접근해도 전체 문서를 적재해야하기에 큰 문서는 낭비 일 수 있다. 문서를 갱신할 때도 보통 전체 문서를 재작성해야 한다. 일반적으로 문서를 아주 작게 유지하면서 문서의 크기가 증가하는 쓰기를 피하라고 권장한다.

지역성을 위해 데이터를 함께 그룹화하는 개념이 문서 모델에만 국한 되지 않는다. 구글의 스패너(Spanner), 오라클의 다중 테이블 색인 클러스터 테이블(multi-table index cluster table) 기능을 사용해 동일한 특성을 제공한다.

##### 문서 데이터베이스와 관계형 데이터베이스의 통합

대부분 관계형 데이터 베이스 시스템은 2000년대 중반 이후로 XML을 지원해서 문서 데이터베이스를 사용할 때와 매우 비슷한 데이터 모델을 애플리케이션이 사용할 수 있다.

문서 데이터베이스 쪽에서 본다면 관계형 조인을 지원하는 등 시간이 지남에 따라 두 데이터베이스는 비슷해지고 있다. 관계형과 문서의 혼합 모델은 미래 데이터베이스들이 가야할 올바른 길이다.



#### 데이터를 위한 질의 언어

**선언형**

SQL

목표를 달성하기 위한 방법이 아니라 알고자 하는 데이터의 패턴, 즉 결과가 충족해야 하는 조건과 데이터를 어떻게 변환할지를 지정.

데이터베이스 엔진의 상세 구현이 숨겨져 있어 질의를 변경하지 않고도 데이터베이스 시스템의 성능을 향상시킬 수 있다.

병렬 실행에 적합.

**명령형**

IMS, 코다실

특정 순서로 특정 연산을 수행하게끔 컴퓨터에게 지시.

다중 코어나 다중 장비에서 병렬처리가 매우 어렵다.

##### 맵리듀스 질의

맵리듀스(MapReduce)는 많은 컴퓨터에서 대량의 데이터를 처리하기 위한 프로그래밍 모델. 많은 문서를 대상으로 읽기 전용(read-only) 질의를 수행할 때 사용.

몽고 DB의 map, reduce 함수는 약간의 제약사항이 존재.

-  순수(pure)함수여아한다.
  
  입력으로 전달된 데이터만 사용하고 추가적인 데이터베이스 질의를 수행할 수 없어야하며 부수 효과(side effect)가 없어야 한다.

맵리듀스의 사용성 문제는 연계된 자바스크립트 함수 두 개를 신중하게 작성해야 한다는 점인데 이는 종종 하나의 질의를 작성하는 것보다 어렵다. 선언형 질의 언어는 질의 최적화기가 질의 성늘을 높일 수 잇는 기회를 제공한다. 이런 이유로 몽고 DB 2.2는 집계 파이프라인(aggregation pipeline)이라 부르는 선언형 질의 언어 지원을 추가했다.



#### 그래프형 데이터 모델

데이터에서 다대다 관계가 일반적이고 데이터 간 연결이 더 복잡해지면 그래프로 데이터를 모델링하기 시작하는 편이 더 자연스럽다.

그래프는 두 유형의 객체로 이뤄진다. 정점(vertex)(노드나 엔티티라고도 한다)과 간선(edge)(관계나 호(arc)라고도 한다)이다. 일반적인 예는 다음과 같다

- 소셜 그래프
  
  정점은 사람이고 간선은 사람들이 서로 알고 있음을 나타낸다.

- 웹그래프
  
  정점은 웹페이지고 간선은 다른 페이지에 대한 HTML 링크를 나타낸다.

- 도로나 철도 네트워크
  
  정점은 교차로이고 간선은 교차로 간 도로나 철로 선을 나타낸다.

위 예제에서는 그래프의 정점은 모두 같은 유형(사람이나 웹 페이지, 도로 교차로)을 나타낸다. 하지만 그래프는 이런 **동종** 데이터에 국한되지 않는다.

예를 들어 페이스북은 다른 여러 유형의 정점과 간선을 단일 그래프로 유지한다. 정점은 사람, 장소, 이벤트, 체크인, 사용자가 작성한 코멘트를 나타내고, 간선은 어떤 사람이 서로 친구인지 어떤 위치에서 체크인이 발생했는지 누가 어떤 포스트에 코멘트를 했는지 누가 이벤트에 참석했는지 등을 나타낸다.

##### 속성 그래프

속성 그래프 모델에서 각 정점은 다음과 같은 요소로 구성된다.

- 고유한 식별자

- 유출(outgoing) 간선 집합

- 유입(incoming) 간선 집합

- 속성 컬렉션(키-값 쌍)

각 간선은 다음과 같은 요소로 구성된다.

- 고유한 식별자

- 간선이 시작하는 정점(꼬리 정점)

- 간선이 끝나는 정점(머리 정점)

- 두 정점 간 관계 유형을 설명하는 레이블

- 속성 컬렉션(키-값 쌍)

이 모델의 중요한 점

- 정점은 다른 정점과 간선으로 연결된다. 특정 유형과 관련 여부를 제한하는 스키마는 없다.

- 정점이 주어지면 정점의 유입과 유출 간선을 효율적으로 찾을 수 있고 그래프를 순회할 수 있다. 즉 일련의 정점을 따라 앞뒤 방향으로 순회한다

- 다른 유형의 관계에 서로 다른 레이블을 사용하면 단일 그래프에 다른 유형의 정보를 저장하면서도 데이터 모델을 깔끔하게 유지할 수 있다.

그래프는 발전성이 좋아서 애플리케이션에 기능을 추가하는 경우 애플리케이션의 데이터 구조 변경을 수용하게끔 그래프를 쉽게 확장할 수 있다.

##### 사이퍼 질의 언어

속성 그래프를 위한 선언형 질의 언어.

##### SQL의 그래프 질의

그래프 데이터를 관계형 구조도로 넣어도 SQL을 사용해 질의 할 수 있을까?

대답은 예지만 약간 어려움. 관계형 데이터베이스에서는 대개 질의에 필요한 조인을 미리 알고 있다. 그래프 질의에서는 미리 조인 수를 고정할 수 없다.

따라서 애플리케이션에 적합한 데이터 모델 선택하는 작업은 중요하다.

##### 트리플 저장소와 스파클

모든 정보를(주어(subject), 서술어(predicate), 목적어(object))처럼 매우 간단한 세 부분 구문(three-part statements) 형식으로 저장한다.

트리플의 주어는 그래프의 정점과 동등하다. 목적어는 두 가지 중 하나다.

- 문자열이나 숫자 같은 원시 데이터타입의 값. 이 경우 트리플의 서술어와 목적어는 주어 정점에서 속성의 키, 값과 동등하다.

- 그래프의 다른 정점. 이 경우 서술어는 그래프의 간선이고 주어는 꼬리 정점이며 목적어는 머리 정점이다.

##### 스파클 질의 언어

스파클(SPARQL)은 RDF 데이터 모델을 사용한 트리플 저장소 질의 언어다.
